<!DOCTYPE html><html lang="en"><head><!--  --><meta charset="utf-8"/><meta author="David Wilson"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="stylesheet" href="/css/bootstrap.min.css"/><link rel="stylesheet" href="/fonts/iosevka-aile/iosevka-aile.css"/><link rel="stylesheet" href="/fonts/jetbrains-mono/jetbrains-mono.css"/><link rel="stylesheet" href="/css/code.css"/><link rel="stylesheet" href="/css/site.css"/><script defer="defer" data-domain="systemcrafters.org" src="https://plausible.io/js/plausible.js"/><title>Managing Files and Directories in Practice - System Crafters</title></head><body><div><div class="blog-header"><div class="container"><div class="row align-items-center justify-content-between"><div class="col-sm-12 col-md-8"><div class="blog-title">System Crafters</div></div><div class="col-sm col-md"><div class="blog-description text-sm-left text-md-right text-lg-right text-xl-right"></div></div></div></div></div><div class="blog-masthead"><div class="container"><div class="row align-items-center justify-content-between"><div class="col-sm-12 col-md-12"><nav class="nav"><a class="nav-link" href="/">Home</a> <a class="nav-link" href="/videos">Videos</a><a class="nav-link" href="https://wiki.systemcrafters.cc">Wiki</a> <a class="nav-link" href="/support-the-channel">Support The Channel</a></nav></div></div></div></div></div><div class="container"><div class="row"><div class="col-sm-12 blog-main"><div class="blog-post"><h1 class="blog-post-title">Managing Files and Directories in Practice</h1><p class="blog-post-meta"></p><div><p>This is Part 6 of the <a href="/learning-emacs-lisp">Learning Emacs Lisp</a> series!
</p>

<p>Watch the video on YouTube: <a href="https://youtu.be/nq-gqNGmayI">https://youtu.be/nq-gqNGmayI</a>
</p>

<p>The final code from this episode can be found <a href="https://github.com/daviwil/dotcrafter.el/blob/8589c71e64b60f9395b418c09b60815a86c7da8f/dotcrafter.el">on GitHub</a>.
</p>

<h2><a id="what-will-we-cover" class="anchor" href="#what-will-we-cover">¶</a>What will we cover?</h2><p>Today we're going to talk about the many ways you can interact with files and directories using Emacs Lisp!
</p>

<p>There are a few different ways to do this with user-facing Emacs functionality (<kbd>find-file</kbd>, <kbd>eshell</kbd>, Dired, etc), but at some point you will want to automate some of these tasks with Emacs Lisp code.
</p>

<p>Today I'll show you a wide range of the functions you have at your disposal and then use them in real code examples!
</p>

<h3><a id="explaining-symbolic-links" class="anchor" href="#explaining-symbolic-links">¶</a>Explaining symbolic links</h3><p>But first, what is a symbolic link?
</p>

<p>It is an entry in the file system that points to a file or directory somewhere else in the file system.  It is used to make it appear like a directory exists at <kbd>~/.emacs.d</kbd> when it actually exists at <kbd>~/.dotfiles/.emacs.d</kbd>!
</p>

<h3><a id="our-project-dotcrafterel" class="anchor" href="#our-project-dotcrafterel">¶</a>Our project: dotcrafter.el</h3><p>As we talked about in previous videos in this series, we are working on a dotfiles management package for Emacs.
</p>

<p>In this video we're going to add functionality to create symbolic links for your configuration files into the real locations where they belong in the home directory!
</p>

<p>Some context:
</p>
<ul><li>We've been focused on dotfiles generated from Org Mode files</li>
<li>You'll probably also have configuration files that don't belong in Org files!</li>
<li>We need a way to automatically link those configuration files into the home directory</li>
<li>We will implement code to "mirror" your configuration files into the home directory using symbolic links</li>
</ul>

<p>By the end of this episode, we'll have a fully working dotfiles management package!
</p>

<p>We'll commit improvements made in this video to the GitHub repository: <a href="https://github.com/daviwil/dotcrafter.el">https://github.com/daviwil/dotcrafter.el</a>
</p>

<p>The starting point of the examples in this episode is <a href="https://github.com/daviwil/dotcrafter.el/blob/0374d5a1ad1e5ecadcdfbdf07e0ae428946b0138/dotcrafter.el">this version of dotcrafter.el</a> from the repository.
</p>

<h2><a id="getting-the-current-directory" class="anchor" href="#getting-the-current-directory">¶</a>Getting the current directory</h2><p>Emacs will resolve most file paths relative to the current directory which is determine by the variable <kbd>default-directory</kbd>.  This buffer-local variable will be different for each buffer you open.
</p>

<p>For file buffers, it will contain the directory where the buffer's file lives:
</p>

<pre><code class="emacs-lisp">
default-directory

</code></pre>

<p>What about the <kbd>*scratch*</kbd> buffer?  It <em>probably</em> returns the directory where Emacs was launched from!
</p>

<p>You can also change <kbd>default-directory</kbd> if necessary!
</p>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/File-Names.html">Emacs Manual: File Names</a>
</p>

<h2><a id="manipulating-file-paths" class="anchor" href="#manipulating-file-paths">¶</a>Manipulating file paths</h2><p>When you want to automate file operations in Emacs, you'll often need to grab different parts of a path so that you can build new paths.  There are a few functions for this purpose!
</p>

<p>In Emacs, file paths are considered to have two parts:
</p>

<ul><li>The directory part</li>
<li>The non-directory part, i.e. the file name and its extension</li>
</ul>

<p>The functions you will want to use for this purpose are all prefixed with <kbd>file-name</kbd>!
</p>

<ul><li><kbd>file-name-directory</kbd>: Get the directory part of a file path</li>
<li><kbd>file-name-nondirectory</kbd>: Get the filename (non-directory) part of a file path</li>
<li><kbd>file-name-extension</kbd>: Get the extension of the file (without the leading period <kbd>.</kbd>)</li>
<li><kbd>file-name-sans-extension</kbd>: Get the path without the file extension</li>
<li><kbd>file-name-base</kbd>: Get the base file name without path or extension</li>
<li><kbd>file-name-as-directory</kbd>: Turn the file name into a directory name</li>
</ul>

<p>NOTE: The file paths you pass to these functions do not have to exist!
</p>

<pre><code class="emacs-lisp">
(file-name-directory (buffer-file-name))

(file-name-nondirectory (buffer-file-name))

(file-name-extension (buffer-file-name))

(file-name-sans-extension (buffer-file-name))

(file-name-base (buffer-file-name))

(file-name-as-directory (buffer-file-name))

(file-name-as-directory
 (file-name-sans-extension (buffer-file-name)))

</code></pre>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/File-Names.html#File-Names">Emacs Lisp Manual: File Names</a>
</p>

<h2><a id="resolving-file-paths" class="anchor" href="#resolving-file-paths">¶</a>Resolving file paths</h2><p>It is a good idea to resolve file paths any time you use them to ensure they are being used for the location you expect!
</p>

<ul><li><kbd>file-name-absolute-p</kbd> will tell you whether a file name is "absolute": it contains a complete file system path</li>
<li><kbd>file-relative-name</kbd> with give you the path of a file relative to another path</li>
<li><kbd>expand-file-name</kbd> will return an absolute path for a file under a specified directory</li>
</ul>

<pre><code class="emacs-lisp">
(file-name-absolute-p (buffer-file-name))      <span class="org-comment-delimiter">;; </span><span class="org-comment">t</span>
(file-name-absolute-p <span class="org-string">"Emacs-Lisp-06.org"</span>)     <span class="org-comment-delimiter">;; </span><span class="org-comment">nil</span>
(file-name-absolute-p <span class="org-string">"dir/Emacs-Lisp-06.org"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">nil</span>

(file-relative-name (buffer-file-name) <span class="org-string">"~/Notes"</span>)     <span class="org-comment-delimiter">;; </span><span class="org-comment">Streams/Emacs-Lisp-06.org</span>
(file-relative-name (buffer-file-name) <span class="org-string">"~/.dotfiles"</span>)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">../Notes/Streams/Emacs-Lisp-06.org</span>

(expand-file-name <span class="org-string">"Emacs-Lisp-06.org"</span>)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">/home/daviwil/Notes/Streams/Emacs-Lisp-06.org</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">The file doesn't have to exist!</span>
(expand-file-name <span class="org-string">"Emacs-Lisp-06.org"</span> <span class="org-string">"~/.dotfiles"</span>)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">/home/daviwil/.dotfiles/Emacs-Lisp-06.org</span>

</code></pre>

<p>What about resolving paths containing environment variables?
</p>

<pre><code class="emacs-lisp">
(expand-file-name <span class="org-string">"$HOME/.emacs.d"</span>)
(substitute-in-file-name <span class="org-string">"$HOME/.emacs.d"</span>)

</code></pre>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Relative-File-Names.html#Relative-File-Names">Emacs Lisp Manual: Absolute and Relative File Names</a>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/File-Name-Expansion.html">Emacs Lisp Manual: Functions that Expand Filenames</a>
</p>

<h2><a id="example-resolving-the-destination-path-of-a-configuration-file" class="anchor" href="#example-resolving-the-destination-path-of-a-configuration-file">¶</a>Example: Resolving the destination path of a configuration file</h2><p>We can use a few of the functions we just discussed to find where a file inside of the dotfiles folder should be linked in the home directory!
</p>

<p>Here's what we need to do:
</p>

<ul><li>Resolve the relative path of a file under the dotfiles folder relative to the dotfiles folder</li>
<li>Resolve that relative path against the home directory (or more specifically the output directory)</li>
</ul>

<p>For example:
</p>

<pre><code class="sh">
~/.dotfiles/.files/

~/.dotfiles/.files/.local/share/applications/Emacs.desktop

  Resolve to --&gt;   .local/share/applications/Emacs.desktop
  Resolve to --&gt; ~/.local/share/applications/Emacs.desktop

</code></pre>

<p>We're also going to define a variable that holds the specific subpath of the dotfiles folder where these linked configuration files should live so that they're easier to manage.
</p>

<pre><code class="emacs-lisp">
(<span class="org-keyword">defcustom</span> <span class="org-variable-name">dotcrafter-dotfiles-folder</span> <span class="org-string">"~/.dotfiles"</span>
  <span class="org-doc">"The folder where dotfiles and org-mode configuration files are stored."</span>
  <span class="org-builtin">:type</span> 'string
  <span class="org-builtin">:group</span> 'dotfiles)

(<span class="org-keyword">defcustom</span> <span class="org-variable-name">dotcrafter-output-directory</span> <span class="org-string">"~"</span>
  <span class="org-doc">"The directory where dotcrafter.el will write out your dotfiles.</span>
<span class="org-doc">This is typically set to the home directory but can be changed</span>
<span class="org-doc">for testing purposes."</span>
  <span class="org-builtin">:type</span> 'string
  <span class="org-builtin">:group</span> 'dotfiles)

(<span class="org-keyword">defcustom</span> <span class="org-variable-name">dotcrafter-config-files-directory</span> <span class="org-string">".files"</span>
  <span class="org-doc">"The directory path inside of `</span><span class="org-doc"><span class="org-constant">dotcrafter-dotfiles-folder</span></span><span class="org-doc">' where</span>
<span class="org-doc">configuration files that should be symbolically linked are stored."</span>
  <span class="org-builtin">:type</span> 'string
  <span class="org-builtin">:group</span> 'dotfiles)

(<span class="org-keyword">setq</span> dotcrafter-dotfiles-folder <span class="org-string">"~/Projects/Code/dotcrafter.el/example"</span>)
(<span class="org-keyword">setq</span> dotcrafter-output-directory <span class="org-string">"~/Projects/Code/dotcrafter.el/demo-output"</span>)

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--resolve-config-files-path</span> ()
  (expand-file-name dotcrafter-config-files-directory
                    dotcrafter-dotfiles-folder))

(<span class="org-keyword">defun</span> <span class="org-function-name">example--resolve-config-file-target</span> (config-file)
  (expand-file-name
   (file-relative-name
    (expand-file-name config-file)
    (dotcrafter--resolve-config-files-path))
   dotcrafter-output-directory))

(example--resolve-config-file-target <span class="org-string">"~/Projects/Code/dotcrafter/example/.files/.emacs.d/init.el"</span>)

</code></pre>

<h2><a id="checking-if-files-and-directories-exist" class="anchor" href="#checking-if-files-and-directories-exist">¶</a>Checking if files and directories exist</h2><p>The <kbd>file-exists-p</kbd> function returns <kbd>t</kbd> if a file or directory exists or <kbd>nil</kbd> otherwise:
</p>

<pre><code class="emacs-lisp">
(file-exists-p <span class="org-string">"~/.dotfiles/.emacs.d"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">t</span>
(file-exists-p <span class="org-string">"~/.dotfiles/foobar"</span>)    <span class="org-comment-delimiter">;; </span><span class="org-comment">nil</span>

</code></pre>

<p>There are a few more functions that you can use to check if the user has access to a file, whether its writable or executable, etc:
</p>

<ul><li><kbd>file-readable-p</kbd></li>
<li><kbd>file-executable-p</kbd></li>
<li><kbd>file-writable-p</kbd></li>
</ul>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Testing-Accessibility.html">Emacs Lisp Manual: Testing Accessibility</a>
</p>

<h2><a id="creating-directories" class="anchor" href="#creating-directories">¶</a>Creating directories</h2><p>You can easily create a directory with the <kbd>make-directory</kbd> command.
</p>

<p>The first parameter is the path to the directory to be created and the second is an optional boolean (<kbd>t</kbd> or <kbd>nil</kbd>) which determines whether any missing parent directories in the path should also be created.
</p>

<p>You can also set the second parameter to <kbd>t</kbd> to ensure that <kbd>make-directory</kbd> won't throw an error if the directory already exists!
</p>

<pre><code class="emacs-lisp">
(make-directory <span class="org-string">"~/.local/share/foobar"</span>)
(make-directory <span class="org-string">"~/.local/share/foobar"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">throws an error</span>
(make-directory <span class="org-string">"~/.local/share/foobar"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">no error!</span>

(make-directory <span class="org-string">"~/.local/share/hello/system/crafters"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">error</span>
(make-directory <span class="org-string">"~/.local/share/hello/system/crafters"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">success!</span>

</code></pre>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Create_002fDelete-Dirs.html">Emacs Lisp Manual: Creating, Copying, and Deleting Directories</a>
</p>

<h2><a id="example-creating-expected-directories-before-linking" class="anchor" href="#example-creating-expected-directories-before-linking">¶</a>Example: Creating expected directories before linking</h2><p>When we begin creating symbolic links into the home directory, one thing we will need to be careful of is creating symbolic links too close to the home directory for commonly-used folders like <kbd>~/.config</kbd> or <kbd>~/.local/share</kbd>.
</p>

<p>What we want to avoid is creating a symlink for these folders to our dotfiles folder and then having a bunch of unwanted files show up there that we must add to our <kbd>.gitignore</kbd>!
</p>

<p>The solution here is to make sure that these directories already exist so that the algorithm we will write later won't try to create symbolic links instead.  To accomplish this, we will create a new variable to hold the list of directories to be pre-created and then create those directories before we start the linking process:
</p>

<pre><code class="emacs-lisp">
(<span class="org-keyword">defcustom</span> <span class="org-variable-name">dotcrafter-ensure-output-directories</span> '(<span class="org-string">".config"</span> <span class="org-string">".local/share"</span>)
  <span class="org-doc">"List of directories in the output folder that should be created</span>
<span class="org-doc">before linking configuration files."</span>
  <span class="org-builtin">:type</span>  '(list string)
  <span class="org-builtin">:group</span> 'dotfiles)

(<span class="org-keyword">defun</span> <span class="org-function-name">example--ensure-output-directories</span> ()
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Ensure that the expected output directories are already</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">created so that links will be created inside</span>
  (<span class="org-keyword">dolist</span> (dir dotcrafter-ensure-output-directories)
    (make-directory (expand-file-name dir dotcrafter-output-directory) t)))

(example--ensure-output-directories)

</code></pre>

<h2><a id="listing-files-in-directories" class="anchor" href="#listing-files-in-directories">¶</a>Listing files in directories</h2><p>One thing you will probably want to do at some point is get a list of files in a given directory, possibly even for all child directories under that path as well.
</p>

<p>The <kbd>directory-files</kbd> and <kbd>directory-files-recursively</kbd> functions are great for this purpose!
</p>

<pre><code class="emacs-lisp">
(directory-files <span class="org-string">"~/.dotfiles"</span>)
(directory-files <span class="org-string">"~/.dotfiles"</span> t)          <span class="org-comment-delimiter">;; </span><span class="org-comment">Return full file paths</span>
(directory-files <span class="org-string">"~/.dotfiles"</span> t <span class="org-string">".org"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Get all file containing ".org"</span>
(directory-files <span class="org-string">"~/.dotfiles"</span> t <span class="org-string">""</span> t)     <span class="org-comment-delimiter">;; </span><span class="org-comment">Don't sort results</span>
(directory-files <span class="org-string">"~/.dotfiles"</span> t <span class="org-string">""</span> nil 3) <span class="org-comment-delimiter">;; </span><span class="org-comment">Maximum 3 results</span>

(directory-files-recursively <span class="org-string">"~/.dotfiles"</span> <span class="org-string">"\\.el$"</span>)
(directory-files-recursively dotcrafter-output-directory <span class="org-string">""</span>)
(directory-files-recursively dotcrafter-output-directory <span class="org-string">""</span> t)

<span class="org-comment-delimiter">;; </span><span class="org-comment">The fourth parameter can be a function that determines whether</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">a path can be traversed using any logic!</span>
(directory-files-recursively <span class="org-string">"~/.emacs.d"</span> <span class="org-string">""</span> nil
                             (<span class="org-keyword">lambda</span> (dir)
                               (string-equal dir <span class="org-string">"~/.emacs.d/lisp"</span>)))

(directory-files-recursively <span class="org-string">"~/.config"</span> <span class="org-string">"\\.scm"</span> t nil nil) <span class="org-comment-delimiter">;; </span><span class="org-comment">Doesn't follow symlinks</span>
(directory-files-recursively <span class="org-string">"~/.config"</span> <span class="org-string">"\\.scm"</span> t nil t)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Follows symlinks!</span>

</code></pre>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Contents-of-Directories.html#Contents-of-Directories">Emacs Lisp Manual: Contents of Directories</a>
</p>

<h2><a id="example-finding-the-list-of-all-configuration-files-to-be-linked" class="anchor" href="#example-finding-the-list-of-all-configuration-files-to-be-linked">¶</a>Example: Finding the list of all configuration files to be linked</h2><p>As we talked about earlier, the goal of what we're doing today is to produce some code that will mirror a folder of configuration files in your dotfiles folder into the home folder using symbolic links.
</p>

<p>We'll use the <kbd>directory-files-recursively</kbd> function to list all of the linkable files under the dotfiles path and then resolve them relative to the output path!
</p>

<pre><code class="emacs-lisp">
(<span class="org-keyword">defun</span> <span class="org-function-name">example--find-all-files-to-link</span> ()
  (<span class="org-keyword">let</span> ((files-to-link
         (directory-files-recursively
          (dotcrafter--resolve-config-files-path)
          <span class="org-string">""</span>)))
    (<span class="org-keyword">dolist</span> (file files-to-link)
      (message <span class="org-string">"File: %s\n   - %s"</span> file (example--resolve-config-file-target file)))))

(example--find-all-files-to-link)

</code></pre>

<h2><a id="copying-moving-and-deleting-files-and-directories" class="anchor" href="#copying-moving-and-deleting-files-and-directories">¶</a>Copying, moving, and deleting files and directories</h2><p>You can perform common file management tasks like copying, moving, and deleting files and directories with a few different Emacs Lisp functions.
</p>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Copying-and-Naming.html">Emacs Lisp Manual: Copying, Naming, and Renaming Files</a>
<a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Create_002fDelete-Dirs.html">Emacs Lisp Manual: Creating, Copying, and Deleting Directories</a>
</p>

<h3><a id="copying" class="anchor" href="#copying">¶</a>Copying</h3><ul><li><kbd>copy-file</kbd>: Copy the contents of one file to another</li>
<li><kbd>copy-directory</kbd>: Copy the contents of one directory to another, including all subdirectories</li>
</ul>

<pre><code class="emacs-lisp">
(copy-file <span class="org-string">"~/.emacs.d/init.el"</span> <span class="org-string">"/tmp"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">Must end in a slash!</span>
(copy-file <span class="org-string">"~/.emacs.d/init.el"</span> <span class="org-string">"/tmp/"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied to /tmp</span>
(copy-file <span class="org-string">"~/.emacs.d/init.el"</span> <span class="org-string">"/tmp/"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Error, already exists!</span>
(copy-file <span class="org-string">"~/.emacs.d/init.el"</span> <span class="org-string">"/tmp/"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">No error!</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">The remaining parameters are all about preserving file metadata</span>

(copy-directory <span class="org-string">"~/.emacs.d/lisp"</span> <span class="org-string">"/tmp"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">Must end in a slash!</span>
(copy-directory <span class="org-string">"~/.emacs.d/lisp"</span> <span class="org-string">"/tmp/"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">Copied to /tmp/lisp</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">To copy the contents of the directory without the enclosing directory:</span>
(copy-directory <span class="org-string">"~/.emacs.d/eshell"</span> <span class="org-string">"/tmp/lisp"</span> t t nil)
(copy-directory <span class="org-string">"~/.emacs.d/eshell"</span> <span class="org-string">"/tmp/lisp"</span> t t t)

</code></pre>

<h3><a id="renaming--moving" class="anchor" href="#renaming--moving">¶</a>Renaming / Moving</h3><ul><li><kbd>rename-file</kbd>: Rename a file or directory</li>
</ul>

<pre><code class="emacs-lisp">
(rename-file <span class="org-string">"/tmp/init.el"</span> <span class="org-string">"/tmp/init-new.el"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">Rename file in same folder</span>
(rename-file <span class="org-string">"/tmp/init-new.el"</span> <span class="org-string">"~/.emacs.d/"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">Move file to different folder</span>
(rename-file <span class="org-string">"~/.emacs.d/init-new.el"</span> <span class="org-string">"~/.emacs.d/init.el"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Error!</span>
(rename-file <span class="org-string">"~/.emacs.d/init-new.el"</span> <span class="org-string">"~/.emacs.d/init.el"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">OK</span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">It can also rename or move directories!</span>
(rename-file <span class="org-string">"/tmp/lisp"</span> <span class="org-string">"/tmp/lisp-two"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">OK</span>
(rename-file <span class="org-string">"/tmp/lisp-two"</span> <span class="org-string">"/tmp/lisp"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">OK</span>

</code></pre>

<h3><a id="deleting" class="anchor" href="#deleting">¶</a>Deleting</h3><ul><li><kbd>delete-file</kbd>: Delete a file, optionally moving it to the trash folder</li>
<li><kbd>delete-directory</kbd>: Deletes a directory, including files if desired</li>
</ul>

<pre><code class="emacs-lisp">
(delete-file <span class="org-string">"/tmp/lisp/dw-desktop.el"</span>)
(delete-file <span class="org-string">"~/.npmrc"</span> t)

(delete-directory <span class="org-string">"/tmp/lisp"</span>)
(delete-directory <span class="org-string">"/tmp/lisp"</span> t)

</code></pre>

<h2><a id="example-migrating-configuration-files-to-the-dotfiles-folder" class="anchor" href="#example-migrating-configuration-files-to-the-dotfiles-folder">¶</a>Example: Migrating configuration files to the dotfiles folder</h2><p>As we continue building our configurations, it's likely that we'll want to migrate a configuration folder into our dotfiles repository.  Let's define a function that will make this really easy for the user:
</p>

<ul><li>The user chooses a folder to move into their dotfiles configuration</li>
<li>We ensure that the chosen file is located under the home directory (<kbd>dotcrafter-output-directory</kbd>)</li>
<li>If so, move the file to the corresponding location under the config path</li>
</ul>

<pre><code class="emacs-lisp">
<span class="org-comment-delimiter">;; </span><span class="org-comment">Run this to feed the demo!</span>
(copy-directory <span class="org-string">"~/.dotfiles/.config/guix"</span>
                (file-name-as-directory (expand-file-name <span class="org-string">".config"</span>
                                                          dotcrafter-output-directory)))
(copy-file <span class="org-string">"~/.dotfiles/.bash_profile"</span>
           (file-name-as-directory dotcrafter-output-directory))

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter-move-to-config-files</span> (source-path)
  <span class="org-doc">"Move a file from the output path to the configuration path."</span>
  (<span class="org-keyword">interactive</span> <span class="org-string">"FConfiguration path to move: "</span>)
  (<span class="org-keyword">let*</span> ((relative-path (file-relative-name (expand-file-name source-path)
                                            dotcrafter-output-directory))
         (dest-path (expand-file-name relative-path
                                      (dotcrafter--resolve-config-files-path)))
         <span class="org-comment-delimiter">;; </span><span class="org-comment">Strip any trailing slash so that we can treat the directory as file</span>
         (dest-path (<span class="org-keyword">if</span> (string-suffix-p <span class="org-string">"/"</span> dest-path)
                        (substring dest-path 0 -1)
                      dest-path)))
         <span class="org-comment-delimiter">;; </span><span class="org-comment">Make sure that the path is under the output directory and that it</span>
         <span class="org-comment-delimiter">;; </span><span class="org-comment">doesn't already exist</span>
         (<span class="org-keyword">when</span> (string-prefix-p <span class="org-string">".."</span> relative-path)
           (<span class="org-warning">error</span> <span class="org-string">"Copied path is not inside of config output directory: %s"</span> dotcrafter-output-directory))
         (<span class="org-keyword">when</span> (file-exists-p dest-path)
           (<span class="org-warning">error</span> <span class="org-string">"Can't copy path because it already exists in the configuration directory: %s"</span> dest-path))

         <span class="org-comment-delimiter">;; </span><span class="org-comment">Ensure that parent directories exist and then move the file!</span>
         (make-directory (file-name-directory dest-path) t)
         (rename-file source-path dest-path)))

    <span class="org-comment-delimiter">;; </span><span class="org-comment">TODO: Link this path back into the dotcrafter-output-directory</span>

</code></pre>

<h2><a id="creating-symbolic-links" class="anchor" href="#creating-symbolic-links">¶</a>Creating symbolic links</h2><p>Using symbolic links, we're able to keep our configuration files in a local Git repository and then make them appear in our home folder.
</p>

<p>Creating symbolic links is very easy in Emacs with the <kbd>make-symbolic-link</kbd> function:
</p>

<pre><code class="emacs-lisp">
(make-symbolic-link <span class="org-string">"~/.dotfiles/.config/guix"</span> <span class="org-string">"~/.config/guix"</span>)   <span class="org-comment-delimiter">;; </span><span class="org-comment">Error if exists</span>
(make-symbolic-link <span class="org-string">"~/.dotfiles/.config/guix"</span> <span class="org-string">"~/.config/guix"</span> t) <span class="org-comment-delimiter">;; </span><span class="org-comment">No error!</span>

</code></pre>

<p>However, this doesn't work exactly the same on Windows!  You might need to run Emacs with elevation for it to work.
</p>

<p>You can also check if a file is a symbolic link using <kbd>file-symlink-p</kbd> and get the path it points to using <kbd>file-truename</kbd>:
</p>

<pre><code class="emacs-lisp">
(file-symlink-p <span class="org-string">"~/.emacs.d"</span>)         <span class="org-comment-delimiter">;; </span><span class="org-comment">.dotfiles/.emacs.d</span>
(file-symlink-p <span class="org-string">"~/.emacs.d/init.el"</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">nil</span>
(file-truename <span class="org-string">"~/.emacs.d/init.el"</span>)  <span class="org-comment-delimiter">;; </span><span class="org-comment">/home/daviwil/.dotfiles/.emacs.d/init.el</span>

</code></pre>

<p><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Copying-and-Naming.html">Emacs Lisp Manual: Copying, Naming, and Renaming Files</a>
</p>

<h2><a id="example-creating-symbolic-links-for-all-configuration-files" class="anchor" href="#example-creating-symbolic-links-for-all-configuration-files">¶</a>Example: Creating symbolic links for all configuration files</h2><p>Here's where everything in this episode finally comes together!
</p>

<p>We're going to implement a more elaborate algorithm that will create symbolic links at the optimal level in the home directory so that we don't need to create a link for every single file.
</p>

<p>If you've ever used GNU Stow, this will look pretty familiar!
</p>

<h3><a id="the-process" class="anchor" href="#the-process">¶</a>The Process</h3><p>This is what we'll do:
</p>

<ul><li>Loop over all files in <kbd>dotcrafter-config-files-directory</kbd></li>
<li>For each file, break the path into pieces for each directory up to the filename</li>
<li>For each piece of the file's path, check if the folder exists</li>
<li>If it exists, check if it's a symbolic link that points to the matching directory in the config folder</li>
<li>If it doesn't exist, create the symlink there</li>
</ul>

<p>Here's a clearer depicton of what this means:
</p>

<pre><code class="sh">
~/.dotfiles/.files/.local/share/applications/Emacs.desktop
                 ~/.local/share/applications/Emacs.desktop
                  L .local exists? YES
                         L share exists? YES
                               L applications exists? NO, create link!
</code></pre>

<h3><a id="the-code" class="anchor" href="#the-code">¶</a>The Code</h3><p>Let's walk through the code line by line before running it!
</p>

<ul><li><kbd>dotcrafter-link-config-files</kbd>: The user-facing function that links the whole config directory</li>
<li><kbd>dotcrafter-link-config-file</kbd>: The "internal" function that handles linking a single file</li>
</ul>

<pre><code class="emacs-lisp">
(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter--link-config-file</span> (config-file)
  <span class="org-comment-delimiter">;; </span><span class="org-comment">Get the "path parts", basically the name of each directory and file in the</span>
  <span class="org-comment-delimiter">;; </span><span class="org-comment">path of config-file</span>
  (<span class="org-keyword">let*</span> ((path-parts
          (split-string (file-relative-name (expand-file-name config-file)
                                            (dotcrafter--resolve-config-files-path))
                        <span class="org-string">"/"</span> t))
         (current-path nil))
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Check each "part" of the path to find the right place to create the symlink.</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Whenever path-parts is nil, stop looping!</span>
    (<span class="org-keyword">while</span> path-parts
      <span class="org-comment-delimiter">;; </span><span class="org-comment">Create the current path using the first part and remove it from the</span>
      <span class="org-comment-delimiter">;; </span><span class="org-comment">front of the list for future iterations</span>
      (<span class="org-keyword">setq</span> current-path (<span class="org-keyword">if</span> current-path
                             (concat current-path <span class="org-string">"/"</span> (car path-parts))
                           (car path-parts)))
      (<span class="org-keyword">setq</span> path-parts (cdr path-parts))

      <span class="org-comment-delimiter">;; </span><span class="org-comment">Figure out whether the current source path can be linked to the target path</span>
      (<span class="org-keyword">let</span> ((source-path (expand-file-name (concat dotcrafter-config-files-directory <span class="org-string">"/"</span> current-path)
                                           dotcrafter-dotfiles-folder))
            (target-path (expand-file-name current-path dotcrafter-output-directory)))
        <span class="org-comment-delimiter">;; </span><span class="org-comment">If the file or directory exists, is it a symbolic link?</span>
        (<span class="org-keyword">if</span> (file-symlink-p target-path)
            <span class="org-comment-delimiter">;; </span><span class="org-comment">If the symbolic link exists, does it point to the source-path?</span>
            (<span class="org-keyword">if</span> (string-equal source-path (file-truename target-path))
                <span class="org-comment-delimiter">;; </span><span class="org-comment">Clear path-parts to stop looping</span>
                (<span class="org-keyword">setq</span> path-parts '())
              (<span class="org-warning">error</span> <span class="org-string">"Path already exists with different symlink! %s"</span> target-path))
          <span class="org-comment-delimiter">;; </span><span class="org-comment">If the target path is an existing directory, we need to keep</span>
          <span class="org-comment-delimiter">;; </span><span class="org-comment">looping, otherwise we can create a symlink here!</span>
          <span class="org-comment-delimiter">;; </span><span class="org-comment">Otherwise, the file is probably a directory so keep looping</span>
          (<span class="org-keyword">when</span> (not (file-directory-p target-path))
            <span class="org-comment-delimiter">;; </span><span class="org-comment">Create a symbolic link to the source-path and</span>
            <span class="org-comment-delimiter">;; </span><span class="org-comment">clear the path-parts so that we stop looping</span>
            (make-symbolic-link source-path target-path)
            (<span class="org-keyword">setq</span> path-parts '())))))))

(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter-link-config-files</span> ()
  (<span class="org-keyword">interactive</span>)
  (<span class="org-keyword">let</span> ((config-files
         (directory-files-recursively
          (dotcrafter--resolve-config-files-path)
          <span class="org-string">""</span>)))
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Ensure that the expected output directories are already</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">created so that links will be created inside</span>
    (<span class="org-keyword">dolist</span> (dir dotcrafter-ensure-output-directories)
      (make-directory (expand-file-name dir dotcrafter-output-directory) t))

    <span class="org-comment-delimiter">;; </span><span class="org-comment">Link all of the source config files to the output path</span>
    (<span class="org-keyword">dolist</span> (file config-files)
      (dotcrafter--link-config-file file))))

</code></pre>

<h2><a id="the-final-code-in-action" class="anchor" href="#the-final-code-in-action">¶</a>The final code in action</h2><p>One last piece will bring together everything we've done in the past few episodes is this function:
</p>

<pre><code class="emacs-lisp">
(<span class="org-keyword">defun</span> <span class="org-function-name">dotcrafter-update-dotfiles</span> ()
  <span class="org-doc">"Generate and link configuration files to the output directory.</span>

<span class="org-doc">This command handles the full process of \"tangling\" Org Mode</span>
<span class="org-doc">files containing configuration blocks and creating symbolic links</span>
<span class="org-doc">to those configuration files in the output directory, typically</span>
<span class="org-doc">the user's home directory."</span>
  (<span class="org-keyword">interactive</span>)
  (dotcrafter-tangle-org-files)
  (dotcrafter-link-config-files)
  (dotcrafter--update-gitignore))

</code></pre>

<p>This will tangle all of our Org configuration files, link all output files to the home directory, and update the <kbd>.gitignore</kbd> to ignore any of the generated files in the repo.
</p>

<p>Let's try it all out!
</p>

<pre><code class="sh">
emacs -Q --batch -l demo.el

</code></pre>

<p>We can also run this function multiple times and it will work just fine!
</p>

<h2><a id="whats-next" class="anchor" href="#whats-next">¶</a>What's next?</h2><p>Now that we've got a functioning package, it's time to take things to the next level by creating major and minor modes for it!
</p>

<p>In the next episode, I'll show you how to create a minor mode to gracefully handle automatic Org file tangling.
</p>

<p>In the following episodes, we'll create a major mode that provides a user interface for the package and then start polishing it up to be published on MELPA!
</p>
</div></div></div></div></div><footer class="blog-footer"><div class="container"><div class="row"><div class="col-sm col-md text-sm-left text-md-right text-lg-right text-xl-right"><p>Made with Emacs 27.2 (Org mode 9.4.4)</p></div></div></div></footer><script src="/js/bootstrap.bundle.min.js"/></body></html>
